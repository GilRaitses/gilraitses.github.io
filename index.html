<!DOCTYPE html>
<html lang="en" class="dark-mode">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gil Raitses | Scientific ML + Simulation</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="Gil Raitses: Researcher in scientific machine learning, signal structuring, and environmental simulation. Expertise in physics-informed models and computational frameworks." />
  <meta name="keywords" content="Gil Raitses, scientific machine learning, neural circuit analysis, signal structuring, marine telemetry, environmental simulation, research" />
  <meta name="author" content="Gil Raitses" />
  
  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="Gil Raitses | Scientific ML + Simulation" />
  <meta property="og:description" content="Researcher in scientific machine learning, signal processing, and environmental simulation." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://gilraitses.github.io/" />
  
  <!-- Accessibility & Device Compatibility -->
  <meta name="theme-color" content="#2b2d42" />
  <meta name="color-scheme" content="light dark" />
  
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <style>
    :root {
      --bg-color: #f9f9f9;
      --text-color: #333;
      --primary-color: #2b2d42;
      --secondary-color: #3c3f60;
      --content-bg: rgba(255, 255, 255, 0.85);
      --header-footer-bg: rgba(43, 45, 66, 0.85);
      --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition-speed: 0.3s;
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      * {
        transition-duration: 0.001s !important;
        animation-duration: 0.001s !important;
      }
      
      .content:hover {
        transform: none !important;
      }
      
      .project-card:hover {
        transform: none !important;
      }
      
      .links a:hover {
        transform: none !important;
      }
      
      section:hover h2 {
        transform: none !important;
      }
      
      .projects li:hover, .current li:hover, .research-themes li:hover {
        transform: none !important;
      }
    }

    /* Mobile-specific styles */
    @media (max-width: 768px) {
      body {
        font-size: 14px;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .content {
        margin: 1rem auto;
        padding: 1rem;
      }
      
      .theme-toggle {
        top: 10px;
        right: 10px;
        width: 35px;
        height: 35px;
      }
      
      .scroll-indicator {
        bottom: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
      }
      
      .project-cards {
        gap: 10px;
      }
      
      .project-card {
        flex: 1 1 100%;
        padding: 12px;
      }
      
      header {
        padding: 1.5rem 1rem;
      }
    }

    .dark-mode {
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --primary-color: #6d72a8;
      --secondary-color: #8186bd;
      --content-bg: rgba(30, 30, 30, 0.85);
      --header-footer-bg: rgba(20, 20, 20, 0.9);
      --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    * {
      box-sizing: border-box;
      transition: background-color var(--transition-speed), color var(--transition-speed);
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      margin: 0;
      padding: 0;
      color: var(--text-color);
      overflow-x: hidden;
      background-color: var(--bg-color);
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
    }

    header {
      background: var(--header-footer-bg);
      color: white;
      padding: 2rem;
      text-align: center;
      position: relative;
      backdrop-filter: blur(5px);
    }

    h1 {
      margin: 0;
      font-size: 2.5rem;
      position: relative;
      display: inline-block;
    }

    h1::after {
      content: '';
      position: absolute;
      width: 0;
      height: 3px;
      bottom: -5px;
      left: 50%;
      background-color: white;
      transition: all 0.5s ease;
    }

    h1:hover::after {
      width: 100%;
      left: 0;
    }

    .content {
      max-width: 800px;
      margin: 2rem auto;
      padding: 1.5rem;
      background: var(--content-bg);
      border-radius: 8px;
      box-shadow: var(--card-shadow);
      backdrop-filter: blur(5px);
      position: relative;
      transition: transform 0.3s ease;
    }

    .content:hover {
      transform: translateY(-5px);
    }

    section {
      margin-bottom: 2rem;
      opacity: 0.9;
      transition: opacity 0.3s ease;
    }

    section:hover {
      opacity: 1;
    }

    h2 {
      color: var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 0.5rem;
      transition: transform 0.3s ease;
    }

    section:hover h2 {
      transform: translateX(10px);
    }

    .projects ul, .current ul, .research-themes ul {
      list-style-type: none;
      padding-left: 0.5rem;
    }

    .projects li, .current li, .research-themes li {
      margin-bottom: 0.8rem;
      position: relative;
      padding-left: 1.5rem;
      transition: transform 0.2s ease;
    }

    .projects li:hover, .current li:hover, .research-themes li:hover {
      transform: translateX(5px);
    }

    .projects li:before, .current li:before, .research-themes li:before {
      content: "▹";
      position: absolute;
      left: 0;
      color: var(--primary-color);
      transition: transform 0.2s ease;
    }

    .projects li:hover:before, .current li:hover:before, .research-themes li:hover:before {
      transform: scale(1.2);
    }

    footer {
      text-align: center;
      font-size: 0.9rem;
      color: white;
      padding: 2rem 0;
      background: var(--header-footer-bg);
      backdrop-filter: blur(5px);
      position: relative;
    }

    a {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: bold;
      transition: all 0.3s;
      position: relative;
    }

    a:hover {
      color: var(--secondary-color);
      text-decoration: none;
    }

    .links a {
      margin: 0 10px;
      padding: 5px 10px;
      border-radius: 4px;
      background: rgba(43, 45, 66, 0.1);
      transition: all 0.3s;
    }

    .links a:hover {
      background: rgba(43, 45, 66, 0.2);
      transform: translateY(-2px);
    }

    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--header-footer-bg);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transition: transform 0.3s ease;
    }

    .theme-toggle:hover {
      transform: rotate(30deg);
    }

    .project-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 15px;
    }

    .project-card {
      flex: 1 1 250px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 15px;
      border: 1px solid rgba(var(--primary-color-rgb), 0.2);
      transition: all 0.3s;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      backdrop-filter: blur(3px);
    }

    /* Style for touch focus on mobile */
    .project-card.touch-focus {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      background: rgba(var(--primary-color-rgb), 0.1);
      border-color: var(--primary-color);
    }

    .project-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      background: rgba(var(--primary-color-rgb), 0.05);
    }

    .project-card h3 {
      margin-top: 0;
      color: var(--primary-color);
    }

    .project-card p {
      font-size: 0.9rem;
      margin-bottom: 0;
    }

    .scroll-indicator {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 50px;
      height: 50px;
      background: var(--header-footer-bg);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .scroll-indicator.visible {
      opacity: 0.8;
    }

    .scroll-indicator:hover {
      opacity: 1;
      transform: translateY(-5px);
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--bg-color);
      z-index: 2000;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      transition: opacity 0.8s ease-out, visibility 0.8s ease-out;
    }

    .loading-overlay.hidden {
      opacity: 0;
      visibility: hidden;
    }

    .brain-container {
      position: relative;
      width: 280px;
      height: 200px;
      margin-bottom: 20px;
    }

    .brain-outline {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .neural-circuit {
      position: absolute;
      border-radius: 50%;
      background-color: var(--primary-color);
      filter: blur(5px);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .loading-text {
      font-size: 1.2rem;
      color: var(--text-color);
      margin-top: 20px;
      letter-spacing: 1px;
    }

    /* Brain model section */
    .brain-model {
      margin-top: 2rem;
    }

    #fly-brain-container {
      width: 100%;
      height: 300px;
      position: relative;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      overflow: hidden;
    }

    #model-controls {
      position: absolute;
      bottom: 15px;
      left: 15px;
      z-index: 10;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    #model-controls button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.8rem;
    }

    #model-controls button:hover {
      background: var(--secondary-color);
      transform: translateY(-2px);
    }

    .model-info {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    @media (max-width: 768px) {
      #fly-brain-container {
        height: 250px;
      }
      
      #model-controls {
        bottom: 10px;
        left: 10px;
      }
      
      #model-controls button {
        padding: 5px 10px;
        font-size: 0.7rem;
      }
    }

    /* FlyWire API Integration Styles */
    .flywire-controls {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(var(--primary-color-rgb), 0.1);
    }
    
    .flywire-controls h3 {
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 1.1rem;
      color: var(--primary-color);
    }
    
    .neuron-selection {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .auth-status, .selection-row, .action-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .status-indicator {
      font-size: 0.9rem;
    }
    
    .api-button, #fetch-neuron {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9rem;
    }
    
    .api-button:hover, #fetch-neuron:hover {
      background: var(--secondary-color);
      transform: translateY(-2px);
    }
    
    .api-button:disabled, #fetch-neuron:disabled, select:disabled {
      background: #cccccc;
      cursor: not-allowed;
      transform: none;
    }
    
    select {
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background: white;
      flex: 1;
    }
    
    .hidden {
      display: none;
    }
    
    .spinner {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
    }
    
    /* Neuron info panel styles */
    #neuron-info-panel {
      margin-top: 15px;
      padding: 12px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 6px;
      border-left: 3px solid var(--primary-color);
    }
    
    #neuron-info-panel h4 {
      margin-top: 0;
      margin-bottom: 10px;
      color: var(--primary-color);
      font-size: 1rem;
    }
    
    .info-content {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .info-row {
      display: flex;
      font-size: 0.9rem;
    }
    
    .info-label {
      font-weight: bold;
      min-width: 80px;
    }
    
    .info-details {
      margin-top: 10px;
      font-size: 0.85rem;
      line-height: 1.4;
      padding: 8px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 4px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Mobile adjustments */
    @media (max-width: 768px) {
      .flywire-controls {
        padding: 10px;
      }
      
      .neuron-selection, .auth-status, .selection-row, .action-row {
        flex-direction: column;
        align-items: stretch;
      }
      
      .api-button, #fetch-neuron {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <canvas id="bg"></canvas>
  
  <button class="theme-toggle" aria-label="Toggle dark/light mode">
    <span class="toggle-icon">☀️</span>
  </button>

  <div class="scroll-indicator" aria-label="Scroll to top" role="button" tabindex="0">
    <span aria-hidden="true">↑</span>
  </div>
  
  <header id="top">
    <h1>Gil Raitses</h1>
    <p>Scientific Machine Learning | Temporal Pattern Analysis | 4D Systems Modeling</p>
  </header>
  
  <div class="content">
    <section class="about-me">
      <h2>Intersections & Influences</h2>
      <p>
        I work at the convergence of art and computational science, searching for patterns that emerge from complex time series data. My creative foundation spans media theory, culinary semiotics, immersive light sculptures, and 3D design for clothing. This artistic exploration led me to question how we perceive and interpret multi-dimensional patterns across domains.
      </p>
      <p>
        My research trajectory began with a fascination for intermodal signal processing in marine mammals—wanting to understand how a dolphin's perceptual field integrates multiple sensory inputs into a cohesive understanding of its environment. Though that film project is on hold, it launched me into investigating temporal pattern synthesis and classification. Currently, I'm exploring how adaptive models can reveal hidden structures in biological signals, environmental systems, and neural activity patterns.
      </p>
    </section>

    <section class="current">
      <h2>Active Research Streams</h2>
      <ul>
        <li><strong>Neural Circuit Analysis:</strong> Planning a framework to explore subjective experience through behavioral analysis of Drosophila larvae. This upcoming project will interpret phase transitions not just as mechanical movements but as meaningful events within a narrative context, integrating the analysis pipeline developed in my current lab work with new approaches to behavioral modeling.</li>
        <li><strong>Marine Behavioral States:</strong> Building a transformer based model to identify and classify humpback whale behavioral states from high resolution dive telemetry, enabling automated detection of feeding events from time series acceleration data.</li>
        <li><strong>Sound Mapping Data:</strong> Using multimodal narrative interpretation of models for immersive analysis of continuous patterns, creating signal processing algorithms that filter environmental noise while preserving biologically relevant signals in complex acoustic environments.</li>
      </ul>
    </section>

    <section class="projects">
      <h2>Framework Implementations</h2>
      <div class="project-cards">
        <div class="project-card">
          <h3>Behavior Subtype Classifier</h3>
          <p>
            A classification system that identifies hierarchical diving patterns in marine mammals using adaptive windowing techniques. This toolkit, developed in partnership with the Parks Lab at Syracuse University, achieves 92% accuracy in detecting feeding, social, and resting behaviors from time series acceleration data. Part of the minGRU based MSTAR framework that enhances annotation intelligence for complex behavioral sequences.
          </p>
        </div>
        <div class="project-card">
          <h3>Drosophila Sensory Circuit Mapping</h3>
          <p>
            Planned framework that will model larval behavioral transitions as dynamic narrative events rather than mechanical shifts. This project, scheduled to begin summer 2025, aims to use state sequence modeling to reconstruct fragmented data into coherent behavioral trajectories. This narrative-based approach treats phase transitions as meaningful moments within a multidimensional state space, bridging observable behavior with hidden internal states.
          </p>
        </div>
        <div class="project-card">
          <h3>Glacial Flow Simulation</h3>
          <p>
            A physics informed neural network approach to predict ice movement patterns using multi resolution satellite data. This model integrates conservation laws with observational data to simulate non linear flow behavior across temporal scales. Currently in development as part of my Master's thesis, exploring how embedding physical constraints within deep learning architectures can transfer between geophysical systems and biological time series analysis.
          </p>
        </div>
      </div>
    </section>

    <section class="research-themes">
      <h2>Methodological Foundations</h2>
      <ul>
        <li>Adaptive windowing and feature extraction from complex signal data</li>
        <li>Memory efficient recurrent architectures for time series classification</li>
        <li>Physics informed constraints in neural network design</li>
        <li>Dynamic state space modeling for behavioral transitions</li>
        <li>Multimodal representation of continuous signal patterns</li>
      </ul>
    </section>

    <section class="links">
      <h2>Connect</h2>
      <p>
        <a href="https://github.com/gilraitses">GitHub</a> ·
        <a href="mailto:gilraitses@gmail.com">Email</a> ·
        <a href="https://www.linkedin.com/in/gilraitses/">LinkedIn</a>
      </p>
    </section>
  </div>
  
  <footer>
    &copy; 2025 Gil Raitses
  </footer>

  <script>
    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({
      canvas: document.querySelector('#bg'),
      antialias: true
    });

    // Flag to track Three.js ready state
    window.threeJsReady = true;

    // Dark/Light mode variables
    let isDarkMode = true;
    const primaryColorDark = 0x6d72a8;
    const primaryColorLight = 0x2b2d42;

    // Initial dark mode settings
    renderer.setClearColor(0x121212, 0.3);
    
    /*
    TODO: Holographic Neural Network Enhancements
    1. Create colorful particle system to represent signal transmission
       - Generate small, bright particles that travel along connections
       - Use rainbow/spectrum colors with gradient effects
       - Make particles emit light to create holographic feel
    
    2. Add motion trails to particles 
       - Implement particle trails using THREE.Points with custom shaders
       - Create fading effect for trails as they move
       - Vary trail length based on activation intensity
    
    3. Implement pulse waves that emanate from activated nodes
       - Create expanding ring effects when neurons activate
       - Use translucent, colorful materials for the pulse rings
       - Add decay effect as rings expand
    
    4. Create color spectrum variations for node activations
       - Replace single-color activation with rainbow spectrum shifts
       - Implement color cycling during node activation periods
       - Use color to indicate activation intensity
    
    5. Add glow effects to enhance holographic appearance
       - Implement bloom post-processing for light elements
       - Create custom shader material for holographic glow
       - Add subtle noise/distortion to materials for holographic feel
    */

    // Responsive handler with performance optimization
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      
      // Set renderer size with lower pixel ratio on mobile
      const pixelRatio = window.innerWidth < 768 ? 
        Math.min(1.5, window.devicePixelRatio) : 
        window.devicePixelRatio;
      
      renderer.setPixelRatio(pixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Adjust node count for performance on resize
      if (window.innerWidth < 768 && neuralNetwork.userData.nodes.length > 40) {
        // Rebuild network with fewer nodes
        scene.remove(neuralNetwork);
        neuralNetwork = createNeuralNetwork();
        scene.add(neuralNetwork);
      }
    });

    // Create a neural network-like structure
    function createNeuralNetwork() {
      const nodeGroup = new THREE.Group();
      
      // Nodes
      const nodeCount = window.innerWidth < 768 ? 40 : 75; // Reduce node count on mobile
      const nodes = [];
      const nodeGeometry = new THREE.SphereGeometry(0.25, 16, 16); // Reduced geometry complexity
      
      // Create multiple node materials for cascading effect
      const nodeMaterials = [
        new THREE.MeshStandardMaterial({ 
          color: 0x6d72a8,
          emissive: 0x6d72a8,
          emissiveIntensity: 0.3,
          metalness: 0.8,
          roughness: 0.2
        }),
        new THREE.MeshStandardMaterial({ 
          color: 0x8a8fd8,
          emissive: 0x8a8fd8,
          emissiveIntensity: 0.5,
          metalness: 0.8,
          roughness: 0.2
        }),
        new THREE.MeshStandardMaterial({ 
          color: 0xa7acff,
          emissive: 0xa7acff,
          emissiveIntensity: 0.7,
          metalness: 0.8,
          roughness: 0.2
        })
      ];

      // Create nodes in a neural network pattern with layers
      const layers = 5;
      const nodesPerLayer = Math.ceil(nodeCount / layers);
      
      for (let layer = 0; layer < layers; layer++) {
        for (let i = 0; i < nodesPerLayer; i++) {
          if (nodes.length >= nodeCount) break;
          
          // Randomly select a material for varied appearance
          const materialIndex = Math.floor(Math.random() * nodeMaterials.length);
          const node = new THREE.Mesh(nodeGeometry, nodeMaterials[materialIndex]);
          
          // Position nodes in layers with some randomization
          const radius = 12 + layer * 2;
          const spread = 6;
          const angleStep = (Math.PI * 2) / nodesPerLayer;
          const angle = i * angleStep + (Math.random() * 0.5);
          
          node.position.x = Math.cos(angle) * radius + (Math.random() - 0.5) * spread;
          node.position.y = (layer - layers/2) * 3 + (Math.random() - 0.5) * 2;
          node.position.z = Math.sin(angle) * radius + (Math.random() - 0.5) * spread;
          
          // Store velocity and activation state for animation
          node.userData = {
            velocity: new THREE.Vector3(
              (Math.random() - 0.5) * 0.03,
              (Math.random() - 0.5) * 0.03,
              (Math.random() - 0.5) * 0.03
            ),
            layer: layer,
            active: false,
            activationTime: 0,
            activationDuration: 1 + Math.random() * 2,
            originalMaterial: materialIndex
          };
          
          nodes.push(node);
          nodeGroup.add(node);
        }
      }

      // Create connections between layers
      const connectionMaterials = [
        new THREE.LineBasicMaterial({ color: 0x6d72a8, transparent: true, opacity: 0.2 }),
        new THREE.LineBasicMaterial({ color: 0x8a8fd8, transparent: true, opacity: 0.5 }),
        new THREE.LineBasicMaterial({ color: 0xa7acff, transparent: true, opacity: 0.8 })
      ];
      
      const connections = [];
      const connectionDistance = 8;

      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          // Create more connections between adjacent layers
          const layerDiff = Math.abs(nodes[i].userData.layer - nodes[j].userData.layer);
          const maxDist = layerDiff === 1 ? connectionDistance : connectionDistance * 0.6;
          
          if (nodes[i].position.distanceTo(nodes[j].position) < maxDist) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
              nodes[i].position,
              nodes[j].position
            ]);
            
            const materialIndex = Math.floor(Math.random() * connectionMaterials.length);
            const line = new THREE.Line(geometry, connectionMaterials[materialIndex]);
            line.userData = {
              pointA: i,
              pointB: j,
              active: false,
              materialIndex: materialIndex,
              activationTime: 0
            };
            
            connections.push(line);
            nodeGroup.add(line);
          }
        }
      }

      // Animation function with cascading activation effect
      let activationTimer = 0;
      nodeGroup.userData = {
        nodes: nodes,
        connections: connections,
        materials: {
          nodes: nodeMaterials,
          connections: connectionMaterials
        },
        update: function(time) {
          // Trigger cascading activation every few seconds
          activationTimer += 0.01;
          if (activationTimer > 3) {
            // Start a new cascade
            this.triggerCascade();
            activationTimer = 0;
          }
          
          // Update node positions and activation states
          for (let node of nodes) {
            node.position.add(node.userData.velocity);
            
            // Bounce at boundaries
            const bounds = 20;
            for (let axis of ['x', 'y', 'z']) {
              if (Math.abs(node.position[axis]) > bounds) {
                node.userData.velocity[axis] *= -1;
              }
            }
            
            // Update activation state
            if (node.userData.active) {
              node.userData.activationTime += 0.05;
              
              // Pulse effect during activation
              const pulse = Math.sin(node.userData.activationTime * 5) * 0.5 + 1;
              node.scale.set(pulse, pulse, pulse);
              
              // Set to bright material during activation
              node.material = nodeMaterials[2]; // Brightest material
              
              // Deactivate after duration
              if (node.userData.activationTime >= node.userData.activationDuration) {
                node.userData.active = false;
                node.material = nodeMaterials[node.userData.originalMaterial];
                node.scale.set(1, 1, 1);
              }
            }
          }
          
          // Update connection geometries and activation
          for (let connection of connections) {
            const pointA = nodes[connection.userData.pointA];
            const pointB = nodes[connection.userData.pointB];
            
            // Update connection geometry
            connection.geometry.setFromPoints([pointA.position, pointB.position]);
            connection.geometry.attributes.position.needsUpdate = true;
            
            // Update activation state for connections
            if (connection.userData.active) {
              connection.userData.activationTime += 0.05;
              connection.material = connectionMaterials[2]; // Brightest material
              
              // Deactivate after duration
              if (connection.userData.activationTime >= 1) {
                connection.userData.active = false;
                connection.material = connectionMaterials[connection.userData.materialIndex];
              }
            }
            
            // Connection visibility based on distance
            connection.visible = pointA.position.distanceTo(pointB.position) < connectionDistance;
          }
        },
        triggerCascade: function() {
          // Start activation at the top layer (layer 0)
          const topLayerNodes = nodes.filter(node => node.userData.layer === 0);
          
          // Randomly select some top layer nodes to start the cascade
          const startCount = Math.ceil(topLayerNodes.length * 0.3);
          for (let i = 0; i < startCount; i++) {
            const index = Math.floor(Math.random() * topLayerNodes.length);
            const node = topLayerNodes[index];
            
            node.userData.active = true;
            node.userData.activationTime = 0;
            
            // Activate connections from this node
            this.activateConnectionsFrom(node);
          }
        },
        activateConnectionsFrom: function(node) {
          // Find connections from this node and activate them
          const nodeIndex = nodes.indexOf(node);
          
          for (let connection of connections) {
            if (connection.userData.pointA === nodeIndex || connection.userData.pointB === nodeIndex) {
              // Activate this connection
              connection.userData.active = true;
              connection.userData.activationTime = 0;
              
              // Find the node at the other end
              const otherNodeIndex = (connection.userData.pointA === nodeIndex) 
                ? connection.userData.pointB 
                : connection.userData.pointA;
              
              const otherNode = nodes[otherNodeIndex];
              
              // If the other node is in a higher layer (higher number), activate it with a delay
              if (otherNode.userData.layer > node.userData.layer) {
                setTimeout(() => {
                  otherNode.userData.active = true;
                  otherNode.userData.activationTime = 0;
                  this.activateConnectionsFrom(otherNode);
                }, 150 * (otherNode.userData.layer - node.userData.layer));
              }
            }
          }
        },
        updateTheme: function(isDark) {
          // No theme changing needed as we're fixed in dark mode
        }
      };
      
      return nodeGroup;
    }

    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    
    // Add directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // Add neural network
    const neuralNetwork = createNeuralNetwork();
    scene.add(neuralNetwork);

    // Animation variables for mouse interaction
    let targetRotationX = 0;
    let targetRotationY = 0;
    let currentRotationX = 0;
    let currentRotationY = 0;

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      
      // Update neural network with time parameter
      neuralNetwork.userData.update(performance.now() * 0.001);
      
      if (!prefersReducedMotion) {
        // Smooth rotation with easing
        currentRotationY += (targetRotationY - currentRotationY) * 0.05;
        currentRotationX += (targetRotationX - currentRotationX) * 0.05;
        
        neuralNetwork.rotation.y = currentRotationY;
        neuralNetwork.rotation.x = currentRotationX;
        
        // Subtle auto-rotation
        targetRotationY += 0.0005;
      } else {
        // For reduced motion, keep a static position
        neuralNetwork.rotation.y = 0.1;
        neuralNetwork.rotation.x = 0.1;
      }
      
      // Render scene
      renderer.render(scene, camera);
    }

    animate();

    // Interactive camera position on mouse move - with reduced motion check
    document.addEventListener('mousemove', (event) => {
      // Skip camera movement if reduced motion is preferred
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
      
      const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
      const mouseY = (event.clientY / window.innerHeight) * 2 - 1;
      
      // Subtle camera movement based on mouse position
      camera.position.x = mouseX * 3;
      camera.position.y = -mouseY * 3;
      camera.lookAt(0, 0, 0);
      
      // Update target rotation based on mouse position
      targetRotationY = mouseX * 0.5;
      targetRotationX = -mouseY * 0.5;
    });

    // Theme toggle functionality
    const themeToggle = document.querySelector('.theme-toggle');
    const toggleIcon = document.querySelector('.toggle-icon');
    const html = document.documentElement;
    
    // Hide the theme toggle button
    themeToggle.style.display = 'none';
    
    // Always start in dark mode
    isDarkMode = true;
    html.classList.add('dark-mode');
    
    // Update neural network function to include cascading effect
    function createNeuralNetwork() {
      const nodeGroup = new THREE.Group();
      
      // Nodes
      const nodeCount = window.innerWidth < 768 ? 40 : 75; // Reduce node count on mobile
      const nodes = [];
      const nodeGeometry = new THREE.SphereGeometry(0.25, 16, 16); // Reduced geometry complexity
      
      // Create multiple node materials for cascading effect
      const nodeMaterials = [
        new THREE.MeshStandardMaterial({ 
          color: 0x6d72a8,
          emissive: 0x6d72a8,
          emissiveIntensity: 0.3,
          metalness: 0.8,
          roughness: 0.2
        }),
        new THREE.MeshStandardMaterial({ 
          color: 0x8a8fd8,
          emissive: 0x8a8fd8,
          emissiveIntensity: 0.5,
          metalness: 0.8,
          roughness: 0.2
        }),
        new THREE.MeshStandardMaterial({ 
          color: 0xa7acff,
          emissive: 0xa7acff,
          emissiveIntensity: 0.7,
          metalness: 0.8,
          roughness: 0.2
        })
      ];

      // Create nodes in a neural network pattern with layers
      const layers = 5;
      const nodesPerLayer = Math.ceil(nodeCount / layers);
      
      for (let layer = 0; layer < layers; layer++) {
        for (let i = 0; i < nodesPerLayer; i++) {
          if (nodes.length >= nodeCount) break;
          
          // Randomly select a material for varied appearance
          const materialIndex = Math.floor(Math.random() * nodeMaterials.length);
          const node = new THREE.Mesh(nodeGeometry, nodeMaterials[materialIndex]);
          
          // Position nodes in layers with some randomization
          const radius = 12 + layer * 2;
          const spread = 6;
          const angleStep = (Math.PI * 2) / nodesPerLayer;
          const angle = i * angleStep + (Math.random() * 0.5);
          
          node.position.x = Math.cos(angle) * radius + (Math.random() - 0.5) * spread;
          node.position.y = (layer - layers/2) * 3 + (Math.random() - 0.5) * 2;
          node.position.z = Math.sin(angle) * radius + (Math.random() - 0.5) * spread;
          
          // Store velocity and activation state for animation
          node.userData = {
            velocity: new THREE.Vector3(
              (Math.random() - 0.5) * 0.03,
              (Math.random() - 0.5) * 0.03,
              (Math.random() - 0.5) * 0.03
            ),
            layer: layer,
            active: false,
            activationTime: 0,
            activationDuration: 1 + Math.random() * 2,
            originalMaterial: materialIndex
          };
          
          nodes.push(node);
          nodeGroup.add(node);
        }
      }

      // Create connections between layers
      const connectionMaterials = [
        new THREE.LineBasicMaterial({ color: 0x6d72a8, transparent: true, opacity: 0.2 }),
        new THREE.LineBasicMaterial({ color: 0x8a8fd8, transparent: true, opacity: 0.5 }),
        new THREE.LineBasicMaterial({ color: 0xa7acff, transparent: true, opacity: 0.8 })
      ];
      
      const connections = [];
      const connectionDistance = 8;

      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          // Create more connections between adjacent layers
          const layerDiff = Math.abs(nodes[i].userData.layer - nodes[j].userData.layer);
          const maxDist = layerDiff === 1 ? connectionDistance : connectionDistance * 0.6;
          
          if (nodes[i].position.distanceTo(nodes[j].position) < maxDist) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
              nodes[i].position,
              nodes[j].position
            ]);
            
            const materialIndex = Math.floor(Math.random() * connectionMaterials.length);
            const line = new THREE.Line(geometry, connectionMaterials[materialIndex]);
            line.userData = {
              pointA: i,
              pointB: j,
              active: false,
              materialIndex: materialIndex,
              activationTime: 0
            };
            
            connections.push(line);
            nodeGroup.add(line);
          }
        }
      }

      // Animation function with cascading activation effect
      let activationTimer = 0;
      nodeGroup.userData = {
        nodes: nodes,
        connections: connections,
        materials: {
          nodes: nodeMaterials,
          connections: connectionMaterials
        },
        update: function(time) {
          // Trigger cascading activation every few seconds
          activationTimer += 0.01;
          if (activationTimer > 3) {
            // Start a new cascade
            this.triggerCascade();
            activationTimer = 0;
          }
          
          // Update node positions and activation states
          for (let node of nodes) {
            node.position.add(node.userData.velocity);
            
            // Bounce at boundaries
            const bounds = 20;
            for (let axis of ['x', 'y', 'z']) {
              if (Math.abs(node.position[axis]) > bounds) {
                node.userData.velocity[axis] *= -1;
              }
            }
            
            // Update activation state
            if (node.userData.active) {
              node.userData.activationTime += 0.05;
              
              // Pulse effect during activation
              const pulse = Math.sin(node.userData.activationTime * 5) * 0.5 + 1;
              node.scale.set(pulse, pulse, pulse);
              
              // Set to bright material during activation
              node.material = nodeMaterials[2]; // Brightest material
              
              // Deactivate after duration
              if (node.userData.activationTime >= node.userData.activationDuration) {
                node.userData.active = false;
                node.material = nodeMaterials[node.userData.originalMaterial];
                node.scale.set(1, 1, 1);
              }
            }
          }
          
          // Update connection geometries and activation
          for (let connection of connections) {
            const pointA = nodes[connection.userData.pointA];
            const pointB = nodes[connection.userData.pointB];
            
            // Update connection geometry
            connection.geometry.setFromPoints([pointA.position, pointB.position]);
            connection.geometry.attributes.position.needsUpdate = true;
            
            // Update activation state for connections
            if (connection.userData.active) {
              connection.userData.activationTime += 0.05;
              connection.material = connectionMaterials[2]; // Brightest material
              
              // Deactivate after duration
              if (connection.userData.activationTime >= 1) {
                connection.userData.active = false;
                connection.material = connectionMaterials[connection.userData.materialIndex];
              }
            }
            
            // Connection visibility based on distance
            connection.visible = pointA.position.distanceTo(pointB.position) < connectionDistance;
          }
        },
        triggerCascade: function() {
          // Start activation at the top layer (layer 0)
          const topLayerNodes = nodes.filter(node => node.userData.layer === 0);
          
          // Randomly select some top layer nodes to start the cascade
          const startCount = Math.ceil(topLayerNodes.length * 0.3);
          for (let i = 0; i < startCount; i++) {
            const index = Math.floor(Math.random() * topLayerNodes.length);
            const node = topLayerNodes[index];
            
            node.userData.active = true;
            node.userData.activationTime = 0;
            
            // Activate connections from this node
            this.activateConnectionsFrom(node);
          }
        },
        activateConnectionsFrom: function(node) {
          // Find connections from this node and activate them
          const nodeIndex = nodes.indexOf(node);
          
          for (let connection of connections) {
            if (connection.userData.pointA === nodeIndex || connection.userData.pointB === nodeIndex) {
              // Activate this connection
              connection.userData.active = true;
              connection.userData.activationTime = 0;
              
              // Find the node at the other end
              const otherNodeIndex = (connection.userData.pointA === nodeIndex) 
                ? connection.userData.pointB 
                : connection.userData.pointA;
              
              const otherNode = nodes[otherNodeIndex];
              
              // If the other node is in a higher layer (higher number), activate it with a delay
              if (otherNode.userData.layer > node.userData.layer) {
                setTimeout(() => {
                  otherNode.userData.active = true;
                  otherNode.userData.activationTime = 0;
                  this.activateConnectionsFrom(otherNode);
                }, 150 * (otherNode.userData.layer - node.userData.layer));
              }
            }
          }
        },
        updateTheme: function(isDark) {
          // No theme changing needed as we're fixed in dark mode
        }
      };
      
      return nodeGroup;
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      
      // Update neural network with time parameter
      neuralNetwork.userData.update(performance.now() * 0.001);
      
      if (!prefersReducedMotion) {
        // Smooth rotation with easing
        currentRotationY += (targetRotationY - currentRotationY) * 0.05;
        currentRotationX += (targetRotationX - currentRotationX) * 0.05;
        
        neuralNetwork.rotation.y = currentRotationY;
        neuralNetwork.rotation.x = currentRotationX;
        
        // Subtle auto-rotation
        targetRotationY += 0.0005;
      } else {
        // For reduced motion, keep a static position
        neuralNetwork.rotation.y = 0.1;
        neuralNetwork.rotation.x = 0.1;
      }
      
      // Render scene
      renderer.render(scene, camera);
    }

    // Calculate RGB from hex for CSS variables
    function hexToRgb(hex) {
      const r = parseInt(hex.substring(1, 3), 16);
      const g = parseInt(hex.substring(3, 5), 16);
      const b = parseInt(hex.substring(5, 7), 16);
      return `${r}, ${g}, ${b}`;
    }

    // Set primary color RGB for CSS variables
    document.documentElement.style.setProperty('--primary-color-rgb', hexToRgb('#2b2d42'));

    // Scroll to top functionality
    const scrollIndicator = document.querySelector('.scroll-indicator');
    
    window.addEventListener('scroll', () => {
      if (window.scrollY > 300) {
        scrollIndicator.classList.add('visible');
      } else {
        scrollIndicator.classList.remove('visible');
      }
    });
    
    scrollIndicator.addEventListener('click', () => {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });

    // Add hover effect to project cards
    const projectCards = document.querySelectorAll('.project-card');
    
    projectCards.forEach(card => {
      card.addEventListener('mouseenter', () => {
        // Create a subtle particle effect around the card on hover
        const cardRect = card.getBoundingClientRect();
        const cardCenterX = cardRect.left + cardRect.width / 2;
        const cardCenterY = cardRect.top + cardRect.height / 2;
        
        // Slightly adjust camera to focus on this area
        targetRotationY = ((cardCenterX / window.innerWidth) * 2 - 1) * 0.3;
        targetRotationX = -((cardCenterY / window.innerHeight) * 2 - 1) * 0.3;
      });
    });

    // Mark Three.js as ready when the scene is loaded
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.position.z = 30;
  </script>
</body>
</html>
