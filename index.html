<!DOCTYPE html>
<html lang="en" class="dark-mode">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gil Raitses | Scientific ML + Simulation</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="Gil Raitses: Researcher in scientific machine learning, signal structuring, and environmental simulation. Expertise in physics-informed models and computational frameworks." />
  <meta name="keywords" content="Gil Raitses, scientific machine learning, neural circuit analysis, signal structuring, marine telemetry, environmental simulation, research" />
  <meta name="author" content="Gil Raitses" />
  
  <!-- Open Graph / Social Media Meta Tags -->
  <meta property="og:title" content="Gil Raitses | Scientific ML + Simulation" />
  <meta property="og:description" content="Researcher in scientific machine learning, signal processing, and environmental simulation." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://gilraitses.github.io/" />
  
  <!-- Accessibility & Device Compatibility -->
  <meta name="theme-color" content="#2b2d42" />
  <meta name="color-scheme" content="light dark" />
  
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <style>
    :root {
      --bg-color: #f9f9f9;
      --text-color: #333;
      --primary-color: #2b2d42;
      --secondary-color: #3c3f60;
      --content-bg: rgba(255, 255, 255, 0.85);
      --header-footer-bg: rgba(43, 45, 66, 0.85);
      --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition-speed: 0.3s;
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
      * {
        transition-duration: 0.001s !important;
        animation-duration: 0.001s !important;
      }
      
      .content:hover {
        transform: none !important;
      }
      
      .project-card:hover {
        transform: none !important;
      }
      
      .links a:hover {
        transform: none !important;
      }
      
      section:hover h2 {
        transform: none !important;
      }
      
      .projects li:hover, .current li:hover, .research-themes li:hover {
        transform: none !important;
      }
    }

    /* Mobile-specific styles */
    @media (max-width: 768px) {
      body {
        font-size: 14px;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .content {
        margin: 1rem auto;
        padding: 1rem;
      }
      
      .theme-toggle {
        top: 10px;
        right: 10px;
        width: 35px;
        height: 35px;
      }
      
      .scroll-indicator {
        bottom: 30px;
        right: 30px;
        width: 50px;
        height: 50px;
        background: var(--header-footer-bg);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.3s ease, transform 0.3s ease;
        z-index: 1000;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }
      
      .scroll-indicator.visible {
        opacity: 0.8;
      }
      
      .scroll-indicator:hover {
        opacity: 1;
        transform: translateY(-5px);
      }
      
      .project-cards {
        gap: 10px;
      }
      
      .project-card {
        flex: 1 1 100%;
        padding: 12px;
      }
      
      header {
        padding: 1.5rem 1rem;
      }
    }

    .dark-mode {
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --primary-color: #6d72a8;
      --secondary-color: #8186bd;
      --content-bg: rgba(30, 30, 30, 0.85);
      --header-footer-bg: rgba(20, 20, 20, 0.9);
      --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    * {
      box-sizing: border-box;
      transition: background-color var(--transition-speed), color var(--transition-speed);
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      margin: 0;
      padding: 0;
      color: var(--text-color);
      overflow-x: hidden;
      background-color: var(--bg-color);
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
    }

    header {
      background: var(--header-footer-bg);
      color: white;
      padding: 2rem;
      text-align: center;
      position: relative;
      backdrop-filter: blur(5px);
    }

    h1 {
      margin: 0;
      font-size: 2.5rem;
      position: relative;
      display: inline-block;
    }

    h1::after {
      content: '';
      position: absolute;
      width: 0;
      height: 3px;
      bottom: -5px;
      left: 50%;
      background-color: white;
      transition: all 0.5s ease;
    }

    h1:hover::after {
      width: 100%;
      left: 0;
    }

    .content {
      max-width: 800px;
      margin: 2rem auto;
      padding: 1.5rem;
      background: var(--content-bg);
      border-radius: 8px;
      box-shadow: var(--card-shadow);
      backdrop-filter: blur(5px);
      position: relative;
      transition: transform 0.3s ease;
    }

    .content:hover {
      transform: translateY(-5px);
    }

    .content section {
      margin-bottom: 2rem;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }
    
    .content section.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .project-card {
      background: rgba(255, 255, 255, 0.04);
      border-radius: 10px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      opacity: 0;
      transform: translateX(-20px);
      transition: opacity 0.5s ease, transform 0.5s ease, background 0.3s ease;
    }
    
    .project-card.visible {
      opacity: 1;
      transform: translateX(0);
    }
    
    .project-card:nth-child(even) {
      transform: translateX(20px);
    }

    .content li {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    .content li.visible {
      opacity: 1;
      transform: translateY(0);
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes fadeInLeft {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    @keyframes fadeInRight {
      from {
        opacity: 0;
        transform: translateX(20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    section {
      margin-bottom: 2rem;
      opacity: 0.9;
      transition: opacity 0.3s ease;
    }

    section:hover {
      opacity: 1;
    }

    h2 {
      color: var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 0.5rem;
      transition: transform 0.3s ease;
    }

    section:hover h2 {
      transform: translateX(10px);
    }

    .projects ul, .current ul, .research-themes ul {
      list-style-type: none;
      padding-left: 0.5rem;
    }

    .projects li, .current li, .research-themes li {
      margin-bottom: 0.8rem;
      position: relative;
      padding-left: 1.5rem;
      transition: transform 0.2s ease;
    }

    .projects li:hover, .current li:hover, .research-themes li:hover {
      transform: translateX(5px);
    }

    .projects li:before, .current li:before, .research-themes li:before {
      content: "▹";
      position: absolute;
      left: 0;
      color: var(--primary-color);
      transition: transform 0.2s ease;
    }

    .projects li:hover:before, .current li:hover:before, .research-themes li:hover:before {
      transform: scale(1.2);
    }

    footer {
      text-align: center;
      font-size: 0.9rem;
      color: white;
      padding: 2rem 0;
      background: var(--header-footer-bg);
      backdrop-filter: blur(5px);
      position: relative;
    }

    a {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: bold;
      transition: all 0.3s;
      position: relative;
    }

    a:hover {
      color: var(--secondary-color);
      text-decoration: none;
    }

    .links a {
      margin: 0 10px;
      padding: 5px 10px;
      border-radius: 4px;
      background: rgba(43, 45, 66, 0.1);
      transition: all 0.3s;
    }

    .links a:hover {
      background: rgba(43, 45, 66, 0.2);
      transform: translateY(-2px);
    }

    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--header-footer-bg);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transition: transform 0.3s ease;
    }

    .theme-toggle:hover {
      transform: rotate(30deg);
    }

    .project-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 15px;
    }

    .project-card {
      flex: 1 1 250px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 15px;
      border: 1px solid rgba(var(--primary-color-rgb), 0.2);
      transition: all 0.3s;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      backdrop-filter: blur(3px);
    }

    /* Style for touch focus on mobile */
    .project-card.touch-focus {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      background: rgba(var(--primary-color-rgb), 0.1);
      border-color: var(--primary-color);
    }

    .project-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      background: rgba(var(--primary-color-rgb), 0.05);
    }

    .project-card h3 {
      margin-top: 0;
      color: var(--primary-color);
    }

    .project-card p {
      font-size: 0.9rem;
      margin-bottom: 0;
    }

    .scroll-indicator {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 50px;
      height: 50px;
      background: var(--header-footer-bg);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .scroll-indicator.visible {
      opacity: 0.8;
    }

    .scroll-indicator:hover {
      opacity: 1;
      transform: translateY(-5px);
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: var(--bg-color);
      z-index: 2000;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      transition: opacity 0.8s ease-out, visibility 0.8s ease-out;
    }

    .loading-overlay.hidden {
      opacity: 0;
      visibility: hidden;
    }

    .brain-container {
      position: relative;
      width: 280px;
      height: 200px;
      margin-bottom: 20px;
    }

    .brain-outline {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .neural-circuit {
      position: absolute;
      border-radius: 50%;
      background-color: var(--primary-color);
      filter: blur(5px);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .loading-text {
      font-size: 1.2rem;
      color: var(--text-color);
      margin-top: 20px;
      letter-spacing: 1px;
    }

    /* Brain model section */
    .brain-model {
      margin-top: 2rem;
    }

    #fly-brain-container {
      width: 100%;
      height: 300px;
      position: relative;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      overflow: hidden;
    }

    #model-controls {
      position: absolute;
      bottom: 15px;
      left: 15px;
      z-index: 10;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    #model-controls button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.8rem;
    }

    #model-controls button:hover {
      background: var(--secondary-color);
      transform: translateY(-2px);
    }

    .model-info {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 0.8rem;
    }

    @media (max-width: 768px) {
      #fly-brain-container {
        height: 250px;
      }
      
      #model-controls {
        bottom: 10px;
        left: 10px;
      }
      
      #model-controls button {
        padding: 5px 10px;
        font-size: 0.7rem;
      }
    }

    /* FlyWire API Integration Styles */
    .flywire-controls {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      border: 1px solid rgba(var(--primary-color-rgb), 0.1);
    }
    
    .flywire-controls h3 {
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 1.1rem;
      color: var(--primary-color);
    }
    
    .neuron-selection {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .auth-status, .selection-row, .action-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .status-indicator {
      font-size: 0.9rem;
    }
    
    .api-button, #fetch-neuron {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9rem;
    }
    
    .api-button:hover, #fetch-neuron:hover {
      background: var(--secondary-color);
      transform: translateY(-2px);
    }
    
    .api-button:disabled, #fetch-neuron:disabled, select:disabled {
      background: #cccccc;
      cursor: not-allowed;
      transform: none;
    }
    
    select {
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background: white;
      flex: 1;
    }
    
    .hidden {
      display: none;
    }
    
    .spinner {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
    }
    
    /* Neuron info panel styles */
    #neuron-info-panel {
      margin-top: 15px;
      padding: 12px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 6px;
      border-left: 3px solid var(--primary-color);
    }
    
    #neuron-info-panel h4 {
      margin-top: 0;
      margin-bottom: 10px;
      color: var(--primary-color);
      font-size: 1rem;
    }
    
    .info-content {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .info-row {
      display: flex;
      font-size: 0.9rem;
    }
    
    .info-label {
      font-weight: bold;
      min-width: 80px;
    }
    
    .info-details {
      margin-top: 10px;
      font-size: 0.85rem;
      line-height: 1.4;
      padding: 8px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 4px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Mobile adjustments */
    @media (max-width: 768px) {
      .flywire-controls {
        padding: 10px;
      }
      
      .neuron-selection, .auth-status, .selection-row, .action-row {
        flex-direction: column;
        align-items: stretch;
      }
      
      .api-button, #fetch-neuron {
        width: 100%;
      }
    }

    /* Background canvas */
    #bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    
    /* Network controls */
    .network-controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 1000;
    }
    
    .network-controls button, .arrangement-controls button {
      background: var(--header-footer-bg);
      color: white;
      border: none;
      border-radius: 5px;
      width: 40px;
      height: 40px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .arrangement-controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 1000;
    }
    
    .arrangement-controls button {
      width: auto;
      padding: 0 10px;
    }
    
    .network-controls button:hover, .arrangement-controls button:hover {
      background: var(--primary-color);
      transform: translateY(-2px);
    }
    
    /* Larvae background */
    #larvae-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      pointer-events: none;
    }
    
    /* Keyboard controls hint */
    .keyboard-controls-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 0.8rem;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 10px;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }
    
    .keyboard-controls-hint:hover {
      opacity: 1;
    }
    
    .key {
      display: inline-block;
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.4);
      border-radius: 3px;
      padding: 2px 6px;
      margin: 0 2px;
      font-family: monospace;
    }
    
    @media (max-width: 768px) {
      .keyboard-controls-hint {
        display: none; /* Hide on mobile */
      }
    }

    /* Project gallery styles */
    .project-gallery {
      margin-top: 3rem;
      padding: 2rem 0;
    }
    
    .filter-controls {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 2rem;
    }
    
    .filter-btn {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: var(--text-color);
      padding: 0.5rem 1rem;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.9rem;
    }
    
    .filter-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .filter-btn.active {
      background: var(--primary-color);
      color: white;
    }
    
    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1.5rem;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.6s ease;
    }
    
    .gallery-grid.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .gallery-item {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      overflow: hidden;
      transition: all 0.3s ease;
      transform-origin: center;
      opacity: 1;
      transform: scale(1);
      display: flex;
      flex-direction: column;
    }
    
    .gallery-item.hidden {
      opacity: 0;
      transform: scale(0.8);
      height: 0;
      margin: 0;
      padding: 0;
      pointer-events: none;
    }
    
    .gallery-item:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
    }
    
    .gallery-item-image {
      height: 180px;
      background-color: rgba(0, 0, 0, 0.1);
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      position: relative;
    }
    
    .gallery-item-image::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.6), transparent);
    }
    
    .gallery-item-tags {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    
    .gallery-item-tag {
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 4px 8px;
      border-radius: 20px;
      font-size: 0.7rem;
      font-weight: 500;
    }
    
    .gallery-item-content {
      padding: 1.2rem;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
    }
    
    .gallery-item-title {
      font-size: 1.2rem;
      margin-bottom: 0.7rem;
      font-weight: 600;
    }
    
    .gallery-item-desc {
      font-size: 0.9rem;
      opacity: 0.8;
      margin-bottom: 1.2rem;
      flex-grow: 1;
    }
    
    .gallery-item-link {
      align-self: flex-start;
      background: var(--primary-color);
      color: white;
      text-decoration: none;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      transition: all 0.3s ease;
    }
    
    .gallery-item-link:hover {
      background: #4b50b3;
      transform: translateY(-2px);
    }
    
    @media (max-width: 768px) {
      .gallery-grid {
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      }
    }

    /* Keyboard shortcuts styles */
    .keyboard-shortcuts {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 0.8rem;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 15px;
      opacity: 0.7;
      transition: opacity 0.3s ease;
      max-width: 90%;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .keyboard-shortcuts:hover {
      opacity: 1;
    }
    
    .shortcut-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 2px 6px;
      min-width: 20px;
      height: 20px;
      font-family: monospace;
      font-weight: 500;
    }
    
    .shortcut-label {
      margin-right: 3px;
      font-size: 0.75rem;
      opacity: 0.9;
    }
    
    @media (max-width: 768px) {
      .keyboard-shortcuts {
        padding: 6px 10px;
        gap: 10px;
      }
      
      .shortcut-group:not(:first-child) {
        display: none;
      }
    }
  </style>
</head>
<body>
  <!-- Add the background canvas elements -->
  <canvas id="bg"></canvas>
  <div id="larvae-background"></div>

  <div class="theme-toggle">🌙</div>
  <div class="scroll-indicator">↑</div>

  <div class="network-controls">
    <button id="zoom-in" aria-label="Zoom in">+</button>
    <button id="zoom-out" aria-label="Zoom out">-</button>
    <button id="reset-view" aria-label="Reset view">⟲</button>
  </div>
  
  <div class="arrangement-controls">
    <button id="arrange-neural" aria-label="Neural network arrangement">Neural</button>
    <button id="arrange-circular" aria-label="Circular arrangement">Circular</button>
    <button id="arrange-random" aria-label="Random arrangement">Random</button>
  </div>
  
  <div class="keyboard-controls-hint">
    <span>Rotate:</span>
    <span><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span></span>
  </div>

  <header>
    <h1>Gil Raitses</h1>
    <p>Scientific Machine Learning | Temporal Pattern Analysis | 4D Systems Modeling</p>
  </header>
  
  <div class="content">
    <section class="about-me">
      <h2>Background & Approach</h2>
      <p>
        I work at the convergence of art and computational science, searching for patterns that emerge from complex time series data. My creative foundation spans media theory, culinary semiotics, immersive light sculptures, and 3D design for clothing. This artistic exploration led me to question how we perceive and interpret multi-dimensional patterns across domains.
      </p>
      <p>
        My research trajectory began with a fascination for intermodal signal processing in marine mammals—wanting to understand how a dolphin's perceptual field integrates multiple sensory inputs into a cohesive understanding of its environment. Though that film project is on hold, it launched me into investigating temporal pattern synthesis and classification. Currently, I'm exploring how adaptive models can reveal hidden structures in biological signals, environmental systems, and neural activity patterns.
      </p>
    </section>

    <section class="current">
      <h2>Active Research Streams</h2>
      <ul>
        <li><strong>Neural Circuit Analysis:</strong> Planning a framework to explore subjective experience through behavioral analysis of Drosophila larvae. This upcoming project will interpret phase transitions not just as mechanical movements but as meaningful events within a narrative context, integrating the analysis pipeline developed in my current lab work with new approaches to behavioral modeling.</li>
        <li><strong>Marine Behavioral States:</strong> Building a transformer based model to identify and classify humpback whale behavioral states from high resolution dive telemetry, enabling automated detection of feeding events from time series acceleration data.</li>
        <li><strong>Sound Mapping Data:</strong> Using multimodal narrative interpretation of models for immersive analysis of continuous patterns, creating signal processing algorithms that filter environmental noise while preserving biologically relevant signals in complex acoustic environments.</li>
      </ul>
    </section>

    <section class="projects">
      <h2>Framework Implementations</h2>
      <div class="project-cards">
        <div class="project-card">
          <h3>Behavior Subtype Classifier</h3>
          <p>
            A classification system that identifies hierarchical diving patterns in marine mammals using adaptive windowing techniques. This toolkit, developed in partnership with the Parks Lab at Syracuse University, achieves 92% accuracy in detecting feeding, social, and resting behaviors from time series acceleration data. Part of the minGRU based MSTAR framework that enhances annotation intelligence for complex behavioral sequences.
          </p>
        </div>
        <div class="project-card">
          <h3>Drosophila Sensory Circuit Mapping</h3>
          <p>
            Planned framework that will model larval behavioral transitions as dynamic narrative events rather than mechanical shifts. This project, scheduled to begin summer 2025, aims to use state sequence modeling to reconstruct fragmented data into coherent behavioral trajectories. This narrative-based approach treats phase transitions as meaningful moments within a multidimensional state space, bridging observable behavior with hidden internal states.
          </p>
        </div>
        <div class="project-card">
          <h3>Glacial Flow Simulation</h3>
          <p>
            A physics informed neural network approach to predict ice movement patterns using multi resolution satellite data. This model integrates conservation laws with observational data to simulate non linear flow behavior across temporal scales. Currently in development as part of my Master's thesis, exploring how embedding physical constraints within deep learning architectures can transfer between geophysical systems and biological time series analysis.
          </p>
        </div>
      </div>
    </section>

    <section class="research-themes">
      <h2>Methodological Foundations</h2>
      <ul>
        <li>Adaptive windowing and feature extraction from complex signal data</li>
        <li>Memory efficient recurrent architectures for time series classification</li>
        <li>Physics informed constraints in neural network design</li>
        <li>Dynamic state space modeling for behavioral transitions</li>
        <li>Multimodal representation of continuous signal patterns</li>
      </ul>
    </section>

    <section class="links">
      <h2>Connect</h2>
      <p>
        <a href="https://github.com/gilraitses">GitHub</a> ·
        <a href="mailto:gilraitses@gmail.com">Email</a> ·
        <a href="https://www.linkedin.com/in/gilraitses/">LinkedIn</a>
      </p>
    </section>
  </div>
  
  <footer>
    &copy; 2025 Gil Raitses
  </footer>

  <section class="project-gallery">
    <h2>Project Gallery</h2>
    <div class="filter-controls">
      <button class="filter-btn active" data-filter="all">All</button>
      <button class="filter-btn" data-filter="framework">Frameworks</button>
      <button class="filter-btn" data-filter="simulation">Simulations</button>
      <button class="filter-btn" data-filter="analysis">Analysis</button>
      <button class="filter-btn" data-filter="visualization">Visualizations</button>
    </div>
    
    <div class="gallery-grid">
      <!-- Gallery Item 1 -->
      <div class="gallery-item" data-category="framework analysis">
        <div class="gallery-item-image" style="background-image: url('https://via.placeholder.com/500/234567')">
          <div class="gallery-item-tags">
            <span class="gallery-item-tag">Framework</span>
            <span class="gallery-item-tag">Analysis</span>
          </div>
        </div>
        <div class="gallery-item-content">
          <h3 class="gallery-item-title">M★ Framework</h3>
          <p class="gallery-item-desc">A behavioral analysis toolkit that identifies complex, nested activities in ecological time-series data.</p>
          <a href="#" class="gallery-item-link">Explore</a>
        </div>
      </div>
      
      <!-- Gallery Item 2 -->
      <div class="gallery-item" data-category="simulation">
        <div class="gallery-item-image" style="background-image: url('https://via.placeholder.com/500/345678')">
          <div class="gallery-item-tags">
            <span class="gallery-item-tag">Simulation</span>
          </div>
        </div>
        <div class="gallery-item-content">
          <h3 class="gallery-item-title">Glacial Flow Simulation</h3>
          <p class="gallery-item-desc">Physics-informed neural network predicting ice movement patterns using multi-resolution satellite data.</p>
          <a href="#" class="gallery-item-link">Explore</a>
        </div>
      </div>
      
      <!-- Gallery Item 3 -->
      <div class="gallery-item" data-category="analysis visualization">
        <div class="gallery-item-image" style="background-image: url('https://via.placeholder.com/500/456789')">
          <div class="gallery-item-tags">
            <span class="gallery-item-tag">Analysis</span>
            <span class="gallery-item-tag">Visualization</span>
          </div>
        </div>
        <div class="gallery-item-content">
          <h3 class="gallery-item-title">Cetacean Dive Analysis</h3>
          <p class="gallery-item-desc">Classification system for diving patterns in marine mammals using adaptive windowing techniques.</p>
          <a href="#" class="gallery-item-link">Explore</a>
        </div>
      </div>
      
      <!-- Gallery Item 4 -->
      <div class="gallery-item" data-category="visualization simulation">
        <div class="gallery-item-image" style="background-image: url('https://via.placeholder.com/500/567890')">
          <div class="gallery-item-tags">
            <span class="gallery-item-tag">Visualization</span>
            <span class="gallery-item-tag">Simulation</span>
          </div>
        </div>
        <div class="gallery-item-content">
          <h3 class="gallery-item-title">Neural Circuit Visualization</h3>
          <p class="gallery-item-desc">Interactive 3D model of neural connectivity patterns for signal processing research.</p>
          <a href="#" class="gallery-item-link">Explore</a>
        </div>
      </div>
      
      <!-- Gallery Item 5 -->
      <div class="gallery-item" data-category="framework">
        <div class="gallery-item-image" style="background-image: url('https://via.placeholder.com/500/678901')">
          <div class="gallery-item-tags">
            <span class="gallery-item-tag">Framework</span>
          </div>
        </div>
        <div class="gallery-item-content">
          <h3 class="gallery-item-title">Adaptive Windowing Library</h3>
          <p class="gallery-item-desc">Specialized tools for signal processing with dynamic temporal window adjustments.</p>
          <a href="#" class="gallery-item-link">Explore</a>
        </div>
      </div>
      
      <!-- Gallery Item 6 -->
      <div class="gallery-item" data-category="analysis">
        <div class="gallery-item-image" style="background-image: url('https://via.placeholder.com/500/789012')">
          <div class="gallery-item-tags">
            <span class="gallery-item-tag">Analysis</span>
          </div>
        </div>
        <div class="gallery-item-content">
          <h3 class="gallery-item-title">Sound Mapping Data</h3>
          <p class="gallery-item-desc">Multimodal narrative interpretation of models for immersive analysis of continuous patterns.</p>
          <a href="#" class="gallery-item-link">Explore</a>
        </div>
      </div>
    </div>
  </section>
  
  <section class="research-themes">
    <h2>Methodological Foundations</h2>
    <ul>
      <li>Adaptive windowing and feature extraction from complex signal data</li>
      <li>Memory efficient recurrent architectures for time series classification</li>
      <li>Physics informed constraints in neural network design</li>
      <li>Dynamic state space modeling for behavioral transitions</li>
      <li>Multimodal representation of continuous signal patterns</li>
    </ul>
  </section>

  <section class="links">
    <h2>Connect</h2>
    <p>
      <a href="https://github.com/gilraitses">GitHub</a> ·
      <a href="mailto:gilraitses@gmail.com">Email</a> ·
      <a href="https://www.linkedin.com/in/gilraitses/">LinkedIn</a>
    </p>
  </section>
  </div>
  
  <footer>
    &copy; 2025 Gil Raitses
  </footer>

  <div class="keyboard-shortcuts">
    <div class="shortcut-group">
      <span class="shortcut-label">Camera:</span>
      <span class="key">W</span>
      <span class="key">A</span>
      <span class="key">S</span>
      <span class="key">D</span>
    </div>
    <div class="shortcut-group">
      <span class="shortcut-label">Rotate:</span>
      <span class="key">↑</span>
      <span class="key">←</span>
      <span class="key">↓</span>
      <span class="key">→</span>
    </div>
    <div class="shortcut-group">
      <span class="shortcut-label">Zoom:</span>
      <span class="key">+</span>
      <span class="key">-</span>
    </div>
    <div class="shortcut-group">
      <span class="shortcut-label">Reset:</span>
      <span class="key">R</span>
    </div>
  </div>

  <script>
    // Global variable to control animations
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    // Dark/Light Mode toggle functionality
    let isDarkMode = document.documentElement.classList.contains('dark-mode');
    const primaryColorDark = 0x6d72a8;
    const primaryColorLight = 0x2b2d42;
    
    // Flag to track Three.js ready state
    window.threeJsReady = true;
    
    // Three.js initialization
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ 
      canvas: document.querySelector('#bg'),
      antialias: true, 
      alpha: true 
    });
    
    // Initialize renderer
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0); // Transparent background
    renderer.setPixelRatio(window.devicePixelRatio);
    
    // Create separate rendering groups for background and foreground
    const backgroundGroup = new THREE.Group();
    const foregroundGroup = new THREE.Group();
    scene.add(backgroundGroup);
    scene.add(foregroundGroup);
    
    // Setup for raycasting and node interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredNode = null;
    let selectedNode = null;
    let isDragging = false;
    
    // Set initial camera position
    camera.position.setZ(30);
    
    // Add some fog for depth
    scene.fog = new THREE.FogExp2(0x000000, 0.01);
    
    // Initialize Drosophila larvae simulation background
    function initDrosophilaBackground() {
      // Create agar plate background
      const plateGeometry = new THREE.PlaneGeometry(60, 60);
      const plateMaterial = new THREE.MeshBasicMaterial({
        color: isDarkMode ? 0x121212 : 0xf0f0f0,
        transparent: true,
        opacity: 0.5
      });
      const agarPlate = new THREE.Mesh(plateGeometry, plateMaterial);
      agarPlate.position.z = -30; // Place behind neural network
      backgroundGroup.add(agarPlate);
      
      // Create grid lines to simulate agar plate edges
      const gridHelper = new THREE.GridHelper(60, 6, 0x444444, 0x444444);
      gridHelper.position.z = -29.9;
      gridHelper.rotation.x = Math.PI / 2;
      backgroundGroup.add(gridHelper);
      
      // Create persistent trajectories group to track larva paths
      const trajectoriesGroup = new THREE.Group();
      trajectoriesGroup.position.z = -29.8;
      backgroundGroup.add(trajectoriesGroup);
      
      // Create larvae
      const larvae = [];
      const larvaeCount = 24; // Number of larvae to simulate
      
      for (let i = 0; i < larvaeCount; i++) {
        // Create a more realistic larva shape with segments
        const larvaLength = 0.8 + Math.random() * 0.4; // Random length
        const segmentCount = 5; // Number of segments
        
        // Create segmented larva
        const curve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(larvaLength * 0.3, 0, 0),
          new THREE.Vector3(larvaLength * 0.6, 0, 0),
          new THREE.Vector3(larvaLength, 0, 0)
        ]);
        
        const points = curve.getPoints(20);
        const larvaGeometry = new THREE.BufferGeometry().setFromPoints(points);
        
        // Create glowing effect that mimics infrared footage
        const larvaMaterial = new THREE.LineBasicMaterial({
          color: 0xdddddd, // Slightly off-white for IR appearance
          linewidth: 3,
          opacity: 0.85,
          transparent: true
        });
        
        const larva = new THREE.Line(larvaGeometry, larvaMaterial);
        
        // Create a glow effect using a point light
        const glowLight = new THREE.PointLight(0xffffff, 0.5, 1);
        glowLight.position.set(larvaLength/2, 0, 0);
        larva.add(glowLight);
        
        // Random starting position on the plate
        const radius = 28; // Slightly smaller than the plate
        const randomAngle = Math.random() * Math.PI * 2;
        const randomRadius = Math.random() * radius;
        larva.position.x = Math.cos(randomAngle) * randomRadius;
        larva.position.y = Math.sin(randomAngle) * randomRadius;
        larva.position.z = -29.5; // Slightly in front of the plate
        
        // Random rotation
        larva.rotation.z = Math.random() * Math.PI * 2;
        
        // Add motion properties
        larva.userData = {
          velocity: 0.02 + Math.random() * 0.03, // Random speed
          direction: larva.rotation.z, // Current movement direction
          lastTurn: 0, // Time counter for turning
          turnInterval: 20 + Math.random() * 40, // Random turning frequency
          wigglePhase: Math.random() * Math.PI * 2, // Phase for wiggling
          wiggleFrequency: 0.2 + Math.random() * 0.3, // Wiggle frequency
          wiggleAmount: 0.05 + Math.random() * 0.1, // Wiggle amplitude
          trailHistory: [], // Store positions for trail
          trailMaxLength: 5 + Math.floor(Math.random() * 3), // Trail length
          size: 0.3 + Math.random() * 0.2, // Size variation
          
          // Add trajectory tracking properties
          trajectoryPoints: [],
          trajectoryColor: new THREE.Color(
            0.5 + Math.random() * 0.5, // R
            0.5 + Math.random() * 0.5, // G
            0.5 + Math.random() * 0.5  // B
          ),
          lastTrajectoryUpdate: 0,
          trajectoryUpdateInterval: 5,
          
          // Add headcasting behavior properties
          isHeadcasting: false,
          headcastTimer: 0,
          headcastInterval: 100 + Math.random() * 200, // Frames between headcasts
          headcastDuration: 0,
          headcastMaxDuration: 0
        };
        
        // Resize larva based on random size
        larva.scale.set(larva.userData.size, larva.userData.size, larva.userData.size);
        
        // Create trail effect that resembles mucus trace
        const trailMaterial = new THREE.LineBasicMaterial({
          color: 0xcccccc, // Subtle silvery trace
          transparent: true,
          opacity: 0.15 // Very faint
        });
        
        const trailGeometry = new THREE.BufferGeometry();
        const trail = new THREE.Line(trailGeometry, trailMaterial);
        larva.add(trail);
        larva.userData.trail = trail;
        
        backgroundGroup.add(larva);
        larvae.push(larva);
      }
      
      return larvae;
    }
    
    // Update larvae positions and behaviors
    function updateLarvae(larvae, deltaTime) {
      // Skip if larvae array is not valid
      if (!Array.isArray(larvae) || larvae.length === 0) return;
      
      // Get reference to trajectories group
      const trajectoriesGroup = backgroundGroup.children.find(child => child.isGroup && child !== foregroundGroup);
      if (!trajectoriesGroup) return;
      
      larvae.forEach(larva => {
        const ud = larva.userData;
        if (!ud) return;
        
        // Handle headcasting behavior (stopping and looking around)
        if (ud.headcastTimer) ud.headcastTimer++;
        if (!ud.isHeadcasting && ud.headcastTimer > ud.headcastInterval) {
          // Start headcasting
          ud.isHeadcasting = true;
          ud.headcastTimer = 0;
          ud.headcastDuration = 0;
          ud.headcastMaxDuration = 20 + Math.floor(Math.random() * 30);
          
          // Save the original velocity
          ud.originalVelocity = ud.velocity;
          ud.velocity = 0; // Stop while headcasting
        }
        
        if (ud.isHeadcasting) {
          // During headcasting, wiggle more dramatically to simulate "looking around"
          if (ud.direction) ud.direction += (Math.random() - 0.5) * 0.5;
          ud.headcastDuration++;
          
          if (ud.headcastDuration > ud.headcastMaxDuration) {
            // End headcasting
            ud.isHeadcasting = false;
            ud.headcastTimer = 0;
            ud.velocity = ud.originalVelocity;
            
            // Choose a new direction after headcasting
            if (ud.direction) ud.direction += (Math.random() * 2 - 1) * Math.PI * 0.7;
          }
        } else if (ud.wigglePhase !== undefined) {
          // Normal movement updates
          // Update wiggle phase
          ud.wigglePhase += ud.wiggleFrequency || 0.2;
          
          // Decide if it's time to change direction
          if (ud.lastTurn !== undefined) {
            ud.lastTurn += 1;
            if (ud.turnInterval && ud.lastTurn > ud.turnInterval) {
              ud.direction += (Math.random() - 0.5) * Math.PI;
              ud.lastTurn = 0;
              ud.turnInterval = 20 + Math.random() * 40;
            }
          }
          
          // Apply small random direction changes to simulate natural movement
          if (ud.direction) ud.direction += (Math.random() - 0.5) * 0.1;
          
          // Add wiggle effect to direction
          const wiggleDirection = ud.direction + (ud.wiggleAmount ? Math.sin(ud.wigglePhase) * ud.wiggleAmount : 0);
          
          // Update position if velocity and direction are available
          if (ud.velocity && wiggleDirection !== undefined) {
            larva.position.x += Math.cos(wiggleDirection) * ud.velocity;
            larva.position.y += Math.sin(wiggleDirection) * ud.velocity;
            larva.rotation.z = wiggleDirection;
          }
        }
        
        // Contain within boundaries (agar plate) if position is valid
        const boundaryRadius = 29;
        const distance = Math.sqrt(larva.position.x ** 2 + larva.position.y ** 2);
        if (distance > boundaryRadius && ud.direction !== undefined) {
          // Turn away from edge with some randomness
          ud.direction = Math.atan2(-larva.position.y, -larva.position.x) + (Math.random() - 0.5) * 0.5;
          
          // Move slightly inward
          larva.position.x = (boundaryRadius * 0.99) * Math.cos(Math.atan2(larva.position.y, larva.position.x));
          larva.position.y = (boundaryRadius * 0.99) * Math.sin(Math.atan2(larva.position.y, larva.position.x));
        }
        
        // Update trajectory (persistent trace) if available
        if (ud.lastTrajectoryUpdate !== undefined && ud.trajectoryUpdateInterval) {
          ud.lastTrajectoryUpdate++;
          if (ud.lastTrajectoryUpdate >= ud.trajectoryUpdateInterval) {
            ud.lastTrajectoryUpdate = 0;
            
            if (ud.trajectoryPoints) {
              // Add current position to trajectory points
              ud.trajectoryPoints.push(new THREE.Vector3(
                larva.position.x,
                larva.position.y,
                -29.7 // Slightly above the plate but below the larvae
              ));
              
              // Update the trajectory line if it exists
              if (ud.trajectoryLine) {
                ud.trajectoryLine.geometry.dispose();
                ud.trajectoryLine.geometry = new THREE.BufferGeometry().setFromPoints(ud.trajectoryPoints);
              }
              // Create trajectory line if it doesn't exist yet
              else if (ud.trajectoryPoints.length > 1 && ud.trajectoryColor) {
                const material = new THREE.LineBasicMaterial({
                  color: ud.trajectoryColor,
                  transparent: true,
                  opacity: 0.3
                });
                
                const geometry = new THREE.BufferGeometry().setFromPoints(ud.trajectoryPoints);
                const line = new THREE.Line(geometry, material);
                
                ud.trajectoryLine = line;
                if (trajectoriesGroup) trajectoriesGroup.add(line);
              }
            }
          }
        }
      });
    }
    
    // Initialize larvae
    const larvae = initDrosophilaBackground();
    
    // Define the neuralNetwork variable
    let neuralNetwork;
    
    // Track intersection objects for hover effects
    function updateMousePosition(event) {
      // Calculate mouse position in normalized device coordinates
      // (-1 to +1) for both components
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }
    
    // Handle hover and selection in animation loop
    function checkNodeInteractions() {
      // Update the picking ray with the camera and mouse position
      raycaster.setFromCamera(mouse, camera);
      
      // Get all the nodes for intersection testing
      const nodes = neuralNetwork ? neuralNetwork.userData.nodes : [];
      
      // Calculate objects intersecting the picking ray
      const intersects = raycaster.intersectObjects(nodes);
      
      // Reset hover state
      if (hoveredNode && hoveredNode !== selectedNode) {
        hoveredNode.scale.set(1, 1, 1);
        document.body.style.cursor = 'auto';
      }
      
      hoveredNode = null;
      
      // Handle new hover
      if (intersects.length > 0 && !isDragging) {
        hoveredNode = intersects[0].object;
        if (hoveredNode !== selectedNode) {
          hoveredNode.scale.set(1.3, 1.3, 1.3);
          document.body.style.cursor = 'pointer';
        }
      }
      
      // Handle dragging
      if (isDragging && selectedNode) {
        // Get intersection with a plane at the camera's target point
        const planeNormal = new THREE.Vector3(0, 0, 1).applyQuaternion(camera.quaternion);
        const plane = new THREE.Plane(planeNormal, -20); // Plane at z=20
        
        const planeIntersect = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, planeIntersect);
        
        // Move the selected node to the intersection point
        selectedNode.position.copy(planeIntersect);
        
        // Flag connections for update
        if (neuralNetwork) {
          const connections = neuralNetwork.userData.connections;
          for (let connection of connections) {
            const nodeIndexA = connection.userData.pointA;
            const nodeIndexB = connection.userData.pointB;
            const node = neuralNetwork.userData.nodes[nodeIndexA];
            const otherNode = neuralNetwork.userData.nodes[nodeIndexB];
            
            if (node === selectedNode || otherNode === selectedNode) {
              connection.geometry.setFromPoints([
                neuralNetwork.userData.nodes[nodeIndexA].position,
                neuralNetwork.userData.nodes[nodeIndexB].position
              ]);
              connection.geometry.attributes.position.needsUpdate = true;
            }
          }
        }
      }
    }
    
    // Responsive handler with performance optimization
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      
      // Set renderer size with lower pixel ratio on mobile
      const pixelRatio = window.innerWidth < 768 ? 
        Math.min(1.5, window.devicePixelRatio) : 
        window.devicePixelRatio;
      
      renderer.setPixelRatio(pixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Adjust node count for performance on resize
      if (window.innerWidth < 768 && neuralNetwork.userData.nodes.length > 40) {
        // Rebuild network with fewer nodes
        scene.remove(neuralNetwork);
        neuralNetwork = createNeuralNetwork();
        scene.add(neuralNetwork);
      }
    });
    
    // Add event listeners for mouse interaction
    document.addEventListener('mousemove', updateMousePosition);
    
    // Mouse down to start dragging
    document.addEventListener('mousedown', (event) => {
      if (hoveredNode) {
        selectedNode = hoveredNode;
        isDragging = true;
        document.body.style.cursor = 'grabbing';
      }
    });
    
    // Mouse up to stop dragging
    document.addEventListener('mouseup', () => {
      isDragging = false;
      
      // Check if we have a selected node that's an anchor
      if (selectedNode && selectedNode.userData && selectedNode.userData.isAnchor) {
        const sectionId = selectedNode.userData.sectionId;
        const section = document.querySelector(sectionId ? `section.${sectionId}` : null);
        
        if (section) {
          // Scroll to the section
          section.scrollIntoView({ behavior: 'smooth' });
        }
      }
      
      selectedNode = null;
      document.body.style.cursor = 'auto';
    });
    
    // Add scroll event listener to highlight anchor nodes when scrolling
    document.addEventListener('scroll', () => {
      // Find which section is currently in view
      const sections = [
        { id: 'about-me', ref: document.querySelector('section.about-me') },
        { id: 'current', ref: document.querySelector('section.current') },
        { id: 'projects', ref: document.querySelector('section.projects') },
        { id: 'research-themes', ref: document.querySelector('section.research-themes') },
        { id: 'links', ref: document.querySelector('section.links') }
      ];
      
      if (!neuralNetwork || !neuralNetwork.userData || !neuralNetwork.userData.nodes) return;
      
      const scrollPosition = window.scrollY + window.innerHeight / 2;
      
      // Find the section that's currently in view
      let activeSection = null;
      
      for (const section of sections) {
        if (!section.ref) continue;
        
        const { top, bottom } = section.ref.getBoundingClientRect();
        const sectionTop = top + window.scrollY;
        const sectionBottom = bottom + window.scrollY;
        
        if (scrollPosition >= sectionTop && scrollPosition <= sectionBottom) {
          activeSection = section.id;
          break;
        }
      }
      
      // Highlight the corresponding anchor node
      if (activeSection) {
        const nodes = neuralNetwork.userData.nodes;
        
        for (const node of nodes) {
          if (node.userData && node.userData.isAnchor) {
            if (node.userData.sectionId === activeSection) {
              // Highlight this node
              if (!node.userData.active) {
                node.userData.active = true;
                node.scale.set(1.5, 1.5, 1.5);
                if (node.material) {
                  node.material.emissiveIntensity = 0.9;
                }
              }
            } else {
              // Reset other nodes
              if (node.userData.active) {
                node.userData.active = false;
                node.scale.set(1, 1, 1);
                if (node.material) {
                  node.material.emissiveIntensity = 0.5;
                }
              }
            }
          }
        }
      }
    });
    
    // Create a neural network-like structure with a simplified implementation
    function createNeuralNetwork() {
      const group = new THREE.Group();
      
      // Create materials for nodes
      const nodeMaterial = new THREE.MeshStandardMaterial({
        color: 0x6d72a8,
        emissive: 0x6d72a8,
        emissiveIntensity: 0.5,
        metalness: 0.9,
        roughness: 0.1
      });
      
      const nodeGeometry = new THREE.SphereGeometry(0.25, 16, 16);
      const nodes = [];
      const connectionMaterial = new THREE.LineBasicMaterial({
        color: 0x6d72a8,
        transparent: true,
        opacity: 0.3
      });
      
      // Create some basic nodes
      const nodeCount = 40;
      
      for (let i = 0; i < nodeCount; i++) {
        const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
        
        // Position each node randomly in a sphere
        const radius = 10;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        node.position.x = radius * Math.sin(phi) * Math.cos(theta);
        node.position.y = radius * Math.sin(phi) * Math.sin(theta);
        node.position.z = radius * Math.cos(phi);
        
        // Add metadata to the node
        node.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.03,
            (Math.random() - 0.5) * 0.03,
            (Math.random() - 0.5) * 0.03
          ),
          isAnchor: false,
          active: false
        };
        
        nodes.push(node);
        group.add(node);
      }
      
      // Create some connections between nodes
      const connections = [];
      
      for (let i = 0; i < nodes.length; i++) {
        // Connect to a few nearby nodes
        for (let j = 0; j < 3; j++) {
          const targetIndex = (i + j + 1) % nodes.length;
          
          const geometry = new THREE.BufferGeometry().setFromPoints([
            nodes[i].position,
            nodes[targetIndex].position
          ]);
          
          const line = new THREE.Line(geometry, connectionMaterial.clone());
          line.userData = {
            pointA: i,
            pointB: targetIndex
          };
          
          connections.push(line);
          group.add(line);
        }
      }
      
      // Store references to the nodes and connections
      group.userData = {
        nodes: nodes,
        connections: connections,
        update: function(time) {
          // Basic animation update
          for (let i = 0; i < nodes.length; i++) {
            // Apply velocity
            nodes[i].position.add(nodes[i].userData.velocity);
            
            // Simple containment - if too far, reverse direction
            const distance = nodes[i].position.length();
            if (distance > 12) {
              nodes[i].userData.velocity.multiplyScalar(-1);
            }
          }
          
          // Update connection lines
          for (let i = 0; i < connections.length; i++) {
            const line = connections[i];
            const pointA = nodes[line.userData.pointA].position;
            const pointB = nodes[line.userData.pointB].position;
            
            line.geometry.dispose();
            line.geometry = new THREE.BufferGeometry().setFromPoints([pointA, pointB]);
          }
        }
      };
      
      // Add a light to the scene
      const light = new THREE.PointLight(0xffffff, 1, 100);
      light.position.set(0, 0, 20);
      group.add(light);
      
      return group;
    }

    // Add ambient light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    
    // Add directional light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Process keyboard controls if available
      if (typeof processKeyboardControls === 'function') {
        processKeyboardControls();
      }
      
      // Check for node interactions
      if (typeof checkNodeInteractions === 'function') {
        checkNodeInteractions();
      }
      
      // Update larvae
      if (typeof updateLarvae === 'function' && larvae) {
        updateLarvae(larvae);
      }
      
      // Rotate the scene slightly for visual interest when not using keyboard
      if (neuralNetwork) {
        if (!isDragging && !prefersReducedMotion && 
            (!keyState || (!keyState.w && !keyState.a && !keyState.s && !keyState.d && 
            !keyState.arrowup && !keyState.arrowleft && !keyState.arrowdown && !keyState.arrowright))) {
          neuralNetwork.rotation.y += 0.002;
          neuralNetwork.rotation.z += 0.001;
        } else if (prefersReducedMotion) {
          // Set to static rotation for reduced motion preference
          neuralNetwork.rotation.y = 0.2;
          neuralNetwork.rotation.z = 0.1;
        }
      }
      
      // Render the scene
      renderer.render(scene, camera);
    }
    
    // Initialize and start the animation
    function init() {
      // Create the neural network
      neuralNetwork = createNeuralNetwork();
      scene.add(neuralNetwork);
      
      // Set initial camera position
      camera.position.z = 30;
      
      // Start the animation loop
      animate();
    }
    
    // Start the application when page is loaded
    window.addEventListener('DOMContentLoaded', () => {
      // Initialize animations
      checkElementsInView();
      
      // Initialize gallery filters if available
      if (typeof initGalleryFilters === 'function') {
        initGalleryFilters();
      }
      
      // Initialize the 3D visualization
      init();
    });

    // Add animation for elements when they come into view
    function checkElementsInView() {
      // Get all sections
      const sections = document.querySelectorAll('.content section');
      
      // Get all project cards
      const projectCards = document.querySelectorAll('.project-card');
      
      // Get all list items
      const listItems = document.querySelectorAll('.content li');
      
      // Options for the Intersection Observer
      const options = {
        root: null, // viewport
        rootMargin: '0px',
        threshold: 0.1 // 10% visibility
      };
      
      // Callback for the observer
      const callback = (entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const delay = entry.target.dataset.delay || 0;
            
            setTimeout(() => {
              entry.target.classList.add('visible');
            }, delay);
            
            // Stop observing once visible
            observer.unobserve(entry.target);
          }
        });
      };
      
      // Create the observer
      const observer = new IntersectionObserver(callback, options);
      
      // Observe sections
      sections.forEach((section, index) => {
        section.dataset.delay = index * 100; // Stagger the animations
        observer.observe(section);
      });
      
      // Observe project cards
      projectCards.forEach((card, index) => {
        card.dataset.delay = index * 150; // Stagger the animations
        observer.observe(card);
      });
      
      // Observe list items
      listItems.forEach((item, index) => {
        item.dataset.delay = index * 100; // Stagger the animations
        observer.observe(item);
      });
    }
    
    // Ensure animations work on page resize
    window.addEventListener('resize', () => {
      checkElementsInView();
    });

    // Gallery filtering functionality
    function initGalleryFilters() {
      const filterButtons = document.querySelectorAll('.filter-btn');
      const galleryItems = document.querySelectorAll('.gallery-item');
      const galleryGrid = document.querySelector('.gallery-grid');
      
      // Add gallery grid to intersection observer
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            galleryGrid.classList.add('visible');
            observer.unobserve(entry.target);
          }
        });
      }, { threshold: 0.1 });
      
      if (galleryGrid) {
        observer.observe(galleryGrid);
      }
      
      // Filter functionality
      filterButtons.forEach(button => {
        button.addEventListener('click', () => {
          // Update active button
          filterButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          
          const filterValue = button.getAttribute('data-filter');
          
          // Filter items
          galleryItems.forEach(item => {
            const categories = item.getAttribute('data-category').split(' ');
            
            if (filterValue === 'all' || categories.includes(filterValue)) {
              item.classList.remove('hidden');
              setTimeout(() => {
                item.style.display = 'flex';
              }, 300);
            } else {
              item.classList.add('hidden');
              setTimeout(() => {
                item.style.display = 'none';
              }, 300);
            }
          });
        });
      });
    }
    
    // Initialize gallery on DOM load
    document.addEventListener('DOMContentLoaded', () => {
      checkElementsInView();
      initGalleryFilters();
    });

    // Keyboard navigation controls
    const keyState = {
      w: false,
      a: false,
      s: false,
      d: false,
      arrowup: false,
      arrowleft: false,
      arrowdown: false,
      arrowright: false,
      plus: false,
      minus: false
    };
    
    // Camera parameters
    let cameraDistance = 30;
    const minDistance = 15;
    const maxDistance = 50;
    let targetRotationX = 0;
    let targetRotationY = 0;
    let currentRotationX = 0;
    let currentRotationY = 0;
    
    // Key down event
    document.addEventListener('keydown', (event) => {
      const key = event.key.toLowerCase();
      if (key in keyState) {
        keyState[key] = true;
        event.preventDefault();
      }
      
      // Check for specific key presses
      if (key === 'r') {
        // Reset view
        resetView();
      } else if (key === '=' || key === '+') {
        // Zoom in
        keyState.plus = true;
      } else if (key === '-' || key === '_') {
        // Zoom out
        keyState.minus = true;
      }
    });
    
    // Key up event
    document.addEventListener('keyup', (event) => {
      const key = event.key.toLowerCase();
      if (key in keyState) {
        keyState[key] = false;
        event.preventDefault();
      }
      
      // Check for specific key releases
      if (key === '=' || key === '+') {
        keyState.plus = false;
      } else if (key === '-' || key === '_') {
        keyState.minus = false;
      }
    });
    
    // Reset view function
    function resetView() {
      cameraDistance = 30;
      targetRotationX = 0;
      targetRotationY = 0;
      currentRotationX = 0;
      currentRotationY = 0;
      
      // Apply changes
      updateCameraPosition();
    }
    
    // Update camera position based on current settings
    function updateCameraPosition() {
      // Calculate camera position using spherical coordinates
      const phi = currentRotationX + Math.PI/2;  // Elevation angle
      const theta = currentRotationY;            // Azimuthal angle
      
      // Update camera position
      camera.position.x = cameraDistance * Math.sin(phi) * Math.cos(theta);
      camera.position.y = cameraDistance * Math.cos(phi);
      camera.position.z = cameraDistance * Math.sin(phi) * Math.sin(theta);
      
      // Look at center of scene
      camera.lookAt(0, 0, 0);
    }
    
    // Process keyboard controls in animation loop
    function processKeyboardControls() {
      // Movement speed values
      const rotationSpeed = 0.03;
      const zoomSpeed = 0.5;
      
      // Handle WASD for camera position
      if (keyState.w) {
        targetRotationX -= rotationSpeed;
      }
      if (keyState.s) {
        targetRotationX += rotationSpeed;
      }
      if (keyState.a) {
        targetRotationY -= rotationSpeed;
      }
      if (keyState.d) {
        targetRotationY += rotationSpeed;
      }
      
      // Handle arrow keys for rotation
      if (keyState.arrowup) {
        targetRotationX -= rotationSpeed;
      }
      if (keyState.arrowdown) {
        targetRotationX += rotationSpeed;
      }
      if (keyState.arrowleft) {
        targetRotationY -= rotationSpeed;
      }
      if (keyState.arrowright) {
        targetRotationY += rotationSpeed;
      }
      
      // Handle zoom with +/- keys
      if (keyState.plus) {
        cameraDistance = Math.max(minDistance, cameraDistance - zoomSpeed);
      }
      if (keyState.minus) {
        cameraDistance = Math.min(maxDistance, cameraDistance + zoomSpeed);
      }
      
      // Apply smooth easing to rotation
      currentRotationX += (targetRotationX - currentRotationX) * 0.05;
      currentRotationY += (targetRotationY - currentRotationY) * 0.05;
      
      // Update camera position
      updateCameraPosition();
    }
  </script>
</body>
</html>
